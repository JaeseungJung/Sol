import { Base58 } from '@ethersproject/basex';
import { BigNumber } from '@ethersproject/bignumber';
import { ContractFactory } from '@ethersproject/contracts';
import { JsonRpcProvider, InfuraProvider } from '@ethersproject/providers';
import DidRegistryContract from 'ethr-did-registry';
import { getAddress } from '@ethersproject/address';
import { computeAddress } from '@ethersproject/transactions';
import * as qs from 'querystring';

function _extends() {
  _extends = Object.assign || function (target) {
    for (var i = 1; i < arguments.length; i++) {
      var source = arguments[i];

      for (var key in source) {
        if (Object.prototype.hasOwnProperty.call(source, key)) {
          target[key] = source[key];
        }
      }
    }

    return target;
  };

  return _extends.apply(this, arguments);
}

const identifierMatcher = /^(.*)?(0x[0-9a-fA-F]{40}|0x[0-9a-fA-F]{66})$/;
const nullAddress = '0x0000000000000000000000000000000000000000';
const DEFAULT_REGISTRY_ADDRESS = '0xdca7ef03e98e0dc2b855be647c39abe984fcf21b';
var verificationMethodTypes;

(function (verificationMethodTypes) {
  verificationMethodTypes["EcdsaSecp256k1VerificationKey2019"] = "EcdsaSecp256k1VerificationKey2019";
  verificationMethodTypes["EcdsaSecp256k1RecoveryMethod2020"] = "EcdsaSecp256k1RecoveryMethod2020";
  verificationMethodTypes["Ed25519VerificationKey2018"] = "Ed25519VerificationKey2018";
  verificationMethodTypes["RSAVerificationKey2018"] = "RSAVerificationKey2018";
  verificationMethodTypes["X25519KeyAgreementKey2019"] = "X25519KeyAgreementKey2019";
})(verificationMethodTypes || (verificationMethodTypes = {}));

var eventNames;

(function (eventNames) {
  eventNames["DIDOwnerChanged"] = "DIDOwnerChanged";
  eventNames["DIDAttributeChanged"] = "DIDAttributeChanged";
  eventNames["DIDDelegateChanged"] = "DIDDelegateChanged";
})(eventNames || (eventNames = {}));

const legacyAttrTypes = {
  sigAuth: 'SignatureAuthentication2018',
  veriKey: 'VerificationKey2018',
  enc: 'KeyAgreementKey2019'
};
const legacyAlgoMap = {
  /**@deprecated */
  Secp256k1VerificationKey2018: verificationMethodTypes.EcdsaSecp256k1VerificationKey2019,

  /**@deprecated */
  Ed25519SignatureAuthentication2018: verificationMethodTypes.Ed25519VerificationKey2018,

  /**@deprecated */
  Secp256k1SignatureAuthentication2018: verificationMethodTypes.EcdsaSecp256k1VerificationKey2019,
  //keep legacy mapping
  RSAVerificationKey2018: verificationMethodTypes.RSAVerificationKey2018,
  Ed25519VerificationKey2018: verificationMethodTypes.Ed25519VerificationKey2018,
  X25519KeyAgreementKey2019: verificationMethodTypes.X25519KeyAgreementKey2019
};
function bytes32toString(input) {
  const buff = typeof input === 'string' ? Buffer.from(input.slice(2), 'hex') : Buffer.from(input);
  return buff.toString('utf8').replace(/\0+$/, '');
}
function stringToBytes32(str) {
  const buffStr = '0x' + Buffer.from(str).slice(0, 32).toString('hex');
  return buffStr + '0'.repeat(66 - buffStr.length);
}
function interpretIdentifier(identifier) {
  let id = identifier;
  let network = undefined;

  if (id.startsWith('did:ethr')) {
    id = id.split('?')[0];
    const components = id.split(':');
    id = components[components.length - 1];

    if (components.length >= 4) {
      network = components.splice(2, components.length - 3).join(':');
    }
  }

  if (id.length > 42) {
    return {
      address: computeAddress(id),
      publicKey: id,
      network
    };
  } else {
    return {
      address: getAddress(id),
      network
    }; // checksum address
  }
}
const knownInfuraNetworks = {
  mainnet: '0x1',
  ropsten: '0x3',
  rinkeby: '0x4',
  goerli: '0x5',
  kovan: '0x2a'
};
const knownNetworks = _extends({}, knownInfuraNetworks, {
  rsk: '0x1e',
  'rsk:testnet': '0x1f',
  artis_t1: '0x03c401',
  artis_s1: '0x03c301',
  matic: '0x89',
  maticmum: '0x13881'
});
var Errors;

(function (Errors) {
  /**
   * The resolver has failed to construct the DID document.
   * This can be caused by a network issue, a wrong registry address or malformed logs while parsing the registry history.
   * Please inspect the `DIDResolutionMetadata.message` to debug further.
   */
  Errors["notFound"] = "notFound";
  /**
   * The resolver does not know how to resolve the given DID. Most likely it is not a `did:ethr`.
   */

  Errors["invalidDid"] = "invalidDid";
  /**
   * The resolver is misconfigured or is being asked to resolve a DID anchored on an unknown network
   */

  Errors["unknownNetwork"] = "unknownNetwork";
})(Errors || (Errors = {}));

function configureNetworksWithInfura(projectId) {
  if (!projectId) {
    return {};
  }

  const networks = [{
    name: 'mainnet',
    chainId: '0x1',
    provider: new InfuraProvider('homestead', projectId)
  }, {
    name: 'ropsten',
    chainId: '0x3',
    provider: new InfuraProvider('ropsten', projectId)
  }, {
    name: 'rinkeby',
    chainId: '0x4',
    provider: new InfuraProvider('rinkeby', projectId)
  }, {
    name: 'goerli',
    chainId: '0x5',
    provider: new InfuraProvider('goerli', projectId)
  }, {
    name: 'kovan',
    chainId: '0x2a',
    provider: new InfuraProvider('kovan', projectId)
  }];
  return configureNetworks({
    networks
  });
}

function getContractForNetwork(conf) {
  var _conf$web;

  let provider = conf.provider || ((_conf$web = conf.web3) == null ? void 0 : _conf$web.currentProvider);

  if (!provider) {
    if (conf.rpcUrl) {
      var _conf$name;

      const chainIdRaw = conf.chainId ? conf.chainId : knownNetworks[conf.name || ''];
      const chainId = chainIdRaw ? BigNumber.from(chainIdRaw).toNumber() : chainIdRaw;
      const networkName = knownInfuraNetworks[conf.name || ''] ? (_conf$name = conf.name) == null ? void 0 : _conf$name.replace('mainnet', 'homestead') : 'any';
      provider = new JsonRpcProvider(conf.rpcUrl, chainId || networkName);
    } else {
      throw new Error(`invalid_config: No web3 provider could be determined for network ${conf.name || conf.chainId}`);
    }
  }

  const contract = ContractFactory.fromSolidity(DidRegistryContract).attach(conf.registry || DEFAULT_REGISTRY_ADDRESS).connect(provider);
  return contract;
}

function configureNetwork(net) {
  const networks = {};
  const chainId = net.chainId || knownNetworks[net.name || ''];

  if (chainId) {
    if (net.name) {
      networks[net.name] = getContractForNetwork(net);
    }

    const id = typeof chainId === 'number' ? `0x${chainId.toString(16)}` : chainId;
    networks[id] = getContractForNetwork(net);
  } else if (net.provider || net.web3 || net.rpcUrl) {
    networks[net.name || ''] = getContractForNetwork(net);
  }

  return networks;
}

function configureNetworks(conf) {
  var _conf$networks;

  return _extends({}, configureNetwork(conf), (_conf$networks = conf.networks) == null ? void 0 : _conf$networks.reduce((networks, net) => {
    return _extends({}, networks, configureNetwork(net));
  }, {}));
}
/**
 * Generates a configuration that maps ethereum network names and chainIDs to the respective ERC1056 contracts deployed on them.
 * @returns a record of ERC1056 `Contract` instances
 * @param conf configuration options for the resolver. An array of network details.
 * Each network entry should contain at least one of `name` or `chainId` AND one of `provider`, `web3`, or `rpcUrl`
 * For convenience, you can also specify an `infuraProjectId` which will create a mapping for all the networks supported by https://infura.io.
 * @example ```js
 * [
 *   { name: 'development', registry: '0x9af37603e98e0dc2b855be647c39abe984fc2445', rpcUrl: 'http://127.0.0.1:8545/' },
 *   { name: 'goerli', chainId: 5, provider: new InfuraProvider('goerli') },
 *   { name: 'rinkeby', provider: new AlchemyProvider('rinkeby') },
 *   { name: 'rsk:testnet', chainId: '0x1f', rpcUrl: 'https://public-node.testnet.rsk.co' },
 * ]
 * ```
 */


function configureResolverWithNetworks(conf = {}) {
  const networks = _extends({}, configureNetworksWithInfura(conf.infuraProjectId), configureNetworks(conf));

  if (Object.keys(networks).length === 0) {
    throw new Error('invalid_config: Please make sure to have at least one network');
  }

  return networks;
}

/**
 * A class that can be used to interact with the ERC1056 contract on behalf of a local controller key-pair
 */

class EthrDidController {
  /**
   * Creates an EthrDidController instance.
   *
   * @param identifier - required - a `did:ethr` string or a publicKeyHex or an ethereum address
   * @param signer - optional - a Signer that represents the current controller key (owner) of the identifier. If a 'signer' is not provided, then a 'contract' with an attached signer can be used.
   * @param contract - optional - a Contract instance representing a ERC1056 contract. At least one of `contract`, `provider`, or `rpcUrl` is required
   * @param chainNameOrId - optional - the network name or chainID, defaults to 'mainnet'
   * @param provider - optional - a web3 Provider. At least one of `contract`, `provider`, or `rpcUrl` is required
   * @param rpcUrl - optional - a JSON-RPC URL that can be used to connect to an ethereum network. At least one of `contract`, `provider`, or `rpcUrl` is required
   * @param registry - optional - The ERC1056 registry address. Defaults to '0xdca7ef03e98e0dc2b855be647c39abe984fcf21b'. Only used with 'provider' or 'rpcUrl'
   */
  constructor(identifier, contract, signer, chainNameOrId = 'mainnet', provider, rpcUrl, registry = DEFAULT_REGISTRY_ADDRESS) {
    this.contract = void 0;
    this.signer = void 0;
    this.address = void 0;
    this.did = void 0;
    // initialize identifier
    const {
      address,
      publicKey,
      network
    } = interpretIdentifier(identifier);
    const net = network || chainNameOrId; // initialize contract connection

    if (contract) {
      this.contract = contract;
    } else if (provider || signer != null && signer.provider || rpcUrl) {
      const prov = provider || (signer == null ? void 0 : signer.provider);
      this.contract = getContractForNetwork({
        name: net,
        provider: prov,
        registry,
        rpcUrl
      });
    } else {
      throw new Error(' either a contract instance or a provider or rpcUrl is required to initialize');
    }

    this.signer = signer;
    this.address = address;
    let networkString = net ? `${net}:` : '';

    if (networkString in ['mainnet:', '0x1:']) {
      networkString = '';
    }

    this.did = publicKey ? `did:ethr:${networkString}${publicKey}` : `did:ethr:${networkString}${address}`;
  }

  async getOwner(address, blockTag) {
    const result = await this.contract.functions.identityOwner(address, {
      blockTag
    });
    return result[0];
  }

  async attachContract(controller) {
    const currentOwner = controller ? await controller : await this.getOwner(this.address, 'latest');
    const signer = this.signer ? this.signer : this.contract.provider.getSigner(currentOwner) || this.contract.signer;
    return this.contract.connect(signer);
  }

  async changeOwner(newOwner, options = {}) {
    // console.log(`changing owner for ${oldOwner} on registry at ${registryContract.address}`)
    const overrides = _extends({
      gasLimit: 123456,
      gasPrice: 1000000000
    }, options);

    const contract = await this.attachContract(overrides.from);
    delete overrides.from;
    const ownerChange = await contract.functions.changeOwner(this.address, newOwner, overrides);
    return await ownerChange.wait();
  }

  async addDelegate(delegateType, delegateAddress, exp, options = {}) {
    const overrides = _extends({
      gasLimit: 123456,
      gasPrice: 1000000000
    }, options);

    const contract = await this.attachContract(overrides.from);
    delete overrides.from;
    const delegateTypeBytes = stringToBytes32(delegateType);
    const addDelegateTx = await contract.functions.addDelegate(this.address, delegateTypeBytes, delegateAddress, exp, overrides);
    return await addDelegateTx.wait();
  }

  async revokeDelegate(delegateType, delegateAddress, options = {}) {
    const overrides = _extends({
      gasLimit: 123456,
      gasPrice: 1000000000
    }, options);

    delegateType = delegateType.startsWith('0x') ? delegateType : stringToBytes32(delegateType);
    const contract = await this.attachContract(overrides.from);
    delete overrides.from;
    const addDelegateTx = await contract.functions.revokeDelegate(this.address, delegateType, delegateAddress, overrides);
    return await addDelegateTx.wait();
  }

  async setAttribute(attrName, attrValue, exp, options = {}) {
    const overrides = _extends({
      gasLimit: 123456,
      gasPrice: 1000000000,
      controller: undefined
    }, options);

    attrName = attrName.startsWith('0x') ? attrName : stringToBytes32(attrName);
    attrValue = attrValue.startsWith('0x') ? attrValue : '0x' + Buffer.from(attrValue, 'utf-8').toString('hex');
    const contract = await this.attachContract(overrides.from);
    delete overrides.from;
    const setAttrTx = await contract.functions.setAttribute(this.address, attrName, attrValue, exp, overrides);
    return await setAttrTx.wait();
  }

  async revokeAttribute(attrName, attrValue, options = {}) {
    // console.log(`revoking attribute ${attrName}(${attrValue}) for ${identity}`)
    const overrides = _extends({
      gasLimit: 123456,
      gasPrice: 1000000000
    }, options);

    attrName = attrName.startsWith('0x') ? attrName : stringToBytes32(attrName);
    attrValue = attrValue.startsWith('0x') ? attrValue : '0x' + Buffer.from(attrValue, 'utf-8').toString('hex');
    const contract = await this.attachContract(overrides.from);
    delete overrides.from;
    const revokeAttributeTX = await contract.functions.revokeAttribute(this.address, attrName, attrValue, overrides);
    return await revokeAttributeTX.wait();
  }

}

function populateEventMetaClass(logResult, blockNumber) {
  // eslint-disable-next-line @typescript-eslint/no-explicit-any
  const result = {};

  if (logResult.eventFragment.inputs.length !== logResult.args.length) {
    throw new TypeError('malformed event input. wrong number of arguments');
  }

  logResult.eventFragment.inputs.forEach((input, index) => {
    let val = logResult.args[index];

    if (typeof val === 'object') {
      val = BigNumber.from(val);
    }

    if (input.type === 'bytes32') {
      val = bytes32toString(val);
    }

    result[input.name] = val;
  });
  result._eventName = logResult.name;
  result.blockNumber = blockNumber;
  return result;
}

function logDecoder(contract, logs) {
  const results = logs.map(log => {
    const res = contract.interface.parseLog(log);
    const event = populateEventMetaClass(res, log.blockNumber);
    return event;
  });
  return results;
}

function getResolver(options) {
  return new EthrDidResolver(options).build();
}
class EthrDidResolver {
  constructor(options) {
    this.contracts = void 0;
    this.contracts = configureResolverWithNetworks(options);
  }
  /**
   * returns the current owner of a DID (represented by an address or public key)
   *
   * @param address
   */


  async getOwner(address, networkId, blockTag) {
    //TODO: check if address or public key
    return new EthrDidController(address, this.contracts[networkId]).getOwner(address, blockTag);
  }
  /**
   * returns the previous change
   *
   * @param address
   */


  async previousChange(address, networkId, blockTag) {
    const result = await this.contracts[networkId].functions.changed(address, {
      blockTag
    }); // console.log(`last change result: '${BigNumber.from(result['0'])}'`)

    return BigNumber.from(result['0']);
  }

  async getBlockMetadata(blockHeight, networkId) {
    const block = await this.contracts[networkId].provider.getBlock(blockHeight);
    return {
      height: block.number.toString(),
      isoDate: new Date(block.timestamp * 1000).toISOString().replace('.000', '')
    };
  }

  async changeLog(identity, networkId, blockTag = 'latest') {
    const contract = this.contracts[networkId];
    const provider = contract.provider;
    const hexChainId = networkId.startsWith('0x') ? networkId : knownNetworks[networkId]; //TODO: this can be used to check if the configuration is ok

    const chainId = hexChainId ? BigNumber.from(hexChainId).toNumber() : (await provider.getNetwork()).chainId;
    const history = [];
    const {
      address,
      publicKey
    } = interpretIdentifier(identity);
    const controllerKey = publicKey;
    let previousChange = await this.previousChange(address, networkId, blockTag);

    while (previousChange) {
      const blockNumber = previousChange; // console.log(`gigel ${previousChange}`)

      const logs = await provider.getLogs({
        address: contract.address,
        // eslint-disable-next-line @typescript-eslint/no-explicit-any
        topics: [null, `0x000000000000000000000000${address.slice(2)}`],
        fromBlock: previousChange.toHexString(),
        toBlock: previousChange.toHexString()
      });
      const events = logDecoder(contract, logs);
      events.reverse();
      previousChange = null;

      for (const event of events) {
        history.unshift(event);

        if (event.previousChange.lt(blockNumber)) {
          previousChange = event.previousChange;
        }
      }
    }

    return {
      address,
      history,
      controllerKey,
      chainId
    };
  }

  wrapDidDocument(did, address, controllerKey, history, chainId, blockHeight, now) {
    var _didDocument$verifica;

    const baseDIDDocument = {
      '@context': ['https://www.w3.org/ns/did/v1', 'https://identity.foundation/EcdsaSecp256k1RecoverySignature2020/lds-ecdsa-secp256k1-recovery2020-0.0.jsonld'],
      id: did,
      verificationMethod: [],
      authentication: [],
      assertionMethod: []
    };
    let controller = address;
    const authentication = [`${did}#controller`];
    let versionId = 0;
    let nextVersionId = Number.POSITIVE_INFINITY;
    let deactivated = false;
    let delegateCount = 0;
    let serviceCount = 0;
    const auth = {};
    const pks = {};
    const services = {};

    for (const event of history) {
      if (blockHeight !== -1 && event.blockNumber > blockHeight) {
        if (nextVersionId > event.blockNumber) {
          nextVersionId = event.blockNumber;
        }

        continue;
      } else {
        if (versionId < event.blockNumber) {
          versionId = event.blockNumber;
        }
      }

      const validTo = event.validTo || BigNumber.from(0);
      const eventIndex = `${event._eventName}-${event.delegateType || event.name}-${event.delegate || event.value}`;

      if (validTo && validTo.gte(now)) {
        if (event._eventName === eventNames.DIDDelegateChanged) {
          const currentEvent = event;
          delegateCount++;
          const delegateType = currentEvent.delegateType; //conversion from bytes32 is done in logParser

          switch (delegateType) {
            case 'sigAuth':
              auth[eventIndex] = `${did}#delegate-${delegateCount}`;
            // eslint-disable-line no-fallthrough

            case 'veriKey':
              pks[eventIndex] = {
                id: `${did}#delegate-${delegateCount}`,
                type: verificationMethodTypes.EcdsaSecp256k1RecoveryMethod2020,
                controller: did,
                blockchainAccountId: `${currentEvent.delegate}@eip155:${chainId}`
              };
              break;
          }
        } else if (event._eventName === eventNames.DIDAttributeChanged) {
          const currentEvent = event;
          const name = currentEvent.name; //conversion from bytes32 is done in logParser

          const match = name.match(/^did\/(pub|svc)\/(\w+)(\/(\w+))?(\/(\w+))?$/);

          if (match) {
            const section = match[1];
            const algorithm = match[2];
            const type = legacyAttrTypes[match[4]] || match[4];
            const encoding = match[6];

            switch (section) {
              case 'pub':
                {
                  delegateCount++;
                  const pk = {
                    id: `${did}#delegate-${delegateCount}`,
                    type: `${algorithm}${type}`,
                    controller: did
                  };
                  pk.type = legacyAlgoMap[pk.type] || algorithm;

                  switch (encoding) {
                    case null:
                    case undefined:
                    case 'hex':
                      pk.publicKeyHex = currentEvent.value.slice(2);
                      break;

                    case 'base64':
                      pk.publicKeyBase64 = Buffer.from(currentEvent.value.slice(2), 'hex').toString('base64');
                      break;

                    case 'base58':
                      pk.publicKeyBase58 = Base58.encode(Buffer.from(currentEvent.value.slice(2), 'hex'));
                      break;

                    case 'pem':
                      pk.publicKeyPem = Buffer.from(currentEvent.value.slice(2), 'hex').toString();
                      break;

                    default:
                      pk.value = currentEvent.value;
                  }

                  pks[eventIndex] = pk;

                  if (match[4] === 'sigAuth') {
                    auth[eventIndex] = pk.id;
                  }

                  break;
                }

              case 'svc':
                serviceCount++;
                services[eventIndex] = {
                  id: `${did}#service-${serviceCount}`,
                  type: algorithm,
                  serviceEndpoint: Buffer.from(currentEvent.value.slice(2), 'hex').toString()
                };
                break;
            }
          }
        }
      } else if (event._eventName === eventNames.DIDOwnerChanged) {
        const currentEvent = event;
        controller = currentEvent.owner;

        if (currentEvent.owner === nullAddress) {
          deactivated = true;
          break;
        }
      } else {
        if (event._eventName === eventNames.DIDDelegateChanged || event._eventName === eventNames.DIDAttributeChanged && event.name.match(/^did\/pub\//)) {
          delegateCount++;
        } else if (event._eventName === eventNames.DIDAttributeChanged && event.name.match(/^did\/svc\//)) {
          serviceCount++;
        }

        delete auth[eventIndex];
        delete pks[eventIndex];
        delete services[eventIndex];
      }
    }

    const publicKeys = [{
      id: `${did}#controller`,
      type: verificationMethodTypes.EcdsaSecp256k1RecoveryMethod2020,
      controller: did,
      blockchainAccountId: `${controller}@eip155:${chainId}`
    }];

    if (controllerKey && controller == address) {
      publicKeys.push({
        id: `${did}#controllerKey`,
        type: verificationMethodTypes.EcdsaSecp256k1VerificationKey2019,
        controller: did,
        publicKeyHex: controllerKey
      });
      authentication.push(`${did}#controllerKey`);
    }

    const didDocument = _extends({}, baseDIDDocument, {
      verificationMethod: publicKeys.concat(Object.values(pks)),
      authentication: authentication.concat(Object.values(auth))
    });

    if (Object.values(services).length > 0) {
      didDocument.service = Object.values(services);
    }

    didDocument.assertionMethod = [...(((_didDocument$verifica = didDocument.verificationMethod) == null ? void 0 : _didDocument$verifica.map(pk => pk.id)) || [])];
    return deactivated ? {
      didDocument: _extends({}, baseDIDDocument, {
        '@context': 'https://www.w3.org/ns/did/v1'
      }),
      deactivated,
      versionId,
      nextVersionId
    } : {
      didDocument,
      deactivated,
      versionId,
      nextVersionId
    };
  }

  async resolve(did, parsed, // eslint-disable-next-line @typescript-eslint/no-unused-vars
  _unused, options) {
    const fullId = parsed.id.match(identifierMatcher);

    if (!fullId) {
      return {
        didResolutionMetadata: {
          error: Errors.invalidDid,
          message: `Not a valid did:ethr: ${parsed.id}`
        },
        didDocumentMetadata: {},
        didDocument: null
      };
    }

    const id = fullId[2];
    const networkId = !fullId[1] ? 'mainnet' : fullId[1].slice(0, -1);
    let blockTag = options.blockTag || 'latest';

    if (typeof parsed.query === 'string') {
      const qParams = qs.decode(parsed.query);
      blockTag = typeof qParams['versionId'] === 'string' ? qParams['versionId'] : blockTag;

      try {
        blockTag = Number.parseInt(blockTag);
      } catch (e) {
        blockTag = 'latest'; // invalid versionId parameters are ignored
      }
    }

    if (!this.contracts[networkId]) {
      return {
        didResolutionMetadata: {
          error: Errors.unknownNetwork,
          message: `The DID resolver does not have a configuration for network: ${networkId}`
        },
        didDocumentMetadata: {},
        didDocument: null
      };
    }

    let now = BigNumber.from(Math.floor(new Date().getTime() / 1000));

    if (typeof blockTag === 'number') {
      const block = await this.getBlockMetadata(blockTag, networkId);
      now = BigNumber.from(Date.parse(block.isoDate) / 1000);
    }

    const {
      address,
      history,
      controllerKey,
      chainId
    } = await this.changeLog(id, networkId, 'latest');

    try {
      const {
        didDocument,
        deactivated,
        versionId,
        nextVersionId
      } = this.wrapDidDocument(did, address, controllerKey, history, chainId, blockTag, now);
      const status = deactivated ? {
        deactivated: true
      } : {};
      let versionMeta = {};
      let versionMetaNext = {};

      if (versionId !== 0) {
        const block = await this.getBlockMetadata(versionId, networkId);
        versionMeta = {
          versionId: block.height,
          updated: block.isoDate
        };
      }

      if (nextVersionId !== Number.POSITIVE_INFINITY) {
        const block = await this.getBlockMetadata(nextVersionId, networkId);
        versionMetaNext = {
          nextVersionId: block.height,
          nextUpdate: block.isoDate
        };
      }

      return {
        didDocumentMetadata: _extends({}, status, versionMeta, versionMetaNext),
        didResolutionMetadata: {
          contentType: 'application/did+ld+json'
        },
        didDocument
      };
    } catch (e) {
      return {
        didResolutionMetadata: {
          error: Errors.notFound,
          message: e.toString() // This is not in spec, nut may be helpful

        },
        didDocumentMetadata: {},
        didDocument: null
      };
    }
  }

  build() {
    return {
      ethr: this.resolve.bind(this)
    };
  }

}

export { Errors, EthrDidController, DEFAULT_REGISTRY_ADDRESS as REGISTRY, legacyAttrTypes as attrTypes, bytes32toString, legacyAlgoMap as delegateTypes, getResolver, identifierMatcher, interpretIdentifier, stringToBytes32, verificationMethodTypes };
//# sourceMappingURL=index.modern.js.map
